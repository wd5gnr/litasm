/**********************************************************************
litasm Copyright 2006, 2007, 2008, 2009, 2023
by Al Williams (al.williams@awce.com)


This file is part of litasm.

litasm is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public Licenses as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

litasmm is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY: without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with axasm (see LICENSE.TXT). 
If not, see http://www.gnu.org/licenses/.

If a non-GPL license is desired, contact the author.

This is the retargetable assembler core file

***********************************************************************/
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>
#include <cassert>
#define _SOLO_MAIN
#include "litasm.h"



static FILE *outfile;
litasm *asmobj;

int main(int argc, char *argv[])
{
  unsigned int endmem,i,j;
  unsigned int siz;
  unsigned mask;
  int opt=0;
  int mode=0;
  outfile=stdout;
  while (opt!=-1)
    {
      opt=getopt(argc,argv,"b8vhixo:");
      switch (opt)
	{
	case '?':
	  fprintf(stderr,"Options: -8 = 8 bit binary mode\n"
		  "-b = 32-bit binary mode (must appear before -o option, if used)\n"
		  "-v = Verilog output\n"
		  "-i = Intel hex mode\n"
		  "-x = Xilinx format\n"
		  "-h = Hex output\n"
		  "-o filename = output file\n");
	  exit(1);
	  break;  // not necessary
	case '8':
	  mode=5;  // 8 bit binary mode
	  break;
	case 'b':
	  mode=4;
	  break;
	case 'v':
	  mode=3;
	  break;
	case 'i':
	  mode=2;
	  break;
	case 'x':
	  mode=1;
	  break;
	case 'h':
	  mode=0;
	  break;

	case 'o':
	  // note -b must be before -o 
	  outfile=fopen(optarg,mode==4?"r+":"w");
	  if (!outfile) 
	    {
	      perror(optarg);
	      return 1;
	    }
	  break;
	}
    }
  

  asmobj = asmobj_create();
  assert(asmobj);
  litasm *lasm=asmobj;
  lasm->dopass(1);
  if (lasm->err==0) lasm->dopass(2);
  if (lasm->err!=0) 
    {
      fprintf(stderr,"Fatal error. No output generated.\n");
      return 1;
    }
  siz=lasm->psize;
  unsigned bytesper=0;
  switch (mode)
    {
    case 1:
      fprintf(outfile,";Generated by soloasm\n");
      fprintf(outfile,"MEMORY_INITIALIZATION_RADIX=16;\n");
      fprintf(outfile,"MEMORY_INITIALIZATION_VECTOR=\n");
      for (i=lasm->begin;i<=lasm->end;i++) fprintf(outfile,"%0*X%c\n",siz/4,lasm->ary[i],i==lasm->end?';':',');
      break;
    case 2:  // basic 64k intel hex file only; psize must be multiple of 8
      mask=0xFF;
      bytesper=16/(siz/8);
      for (i=lasm->begin;i<=lasm->end;i+=bytesper)
	{
	  /* need to compute # of output words on this line */
	  unsigned lsize=bytesper;  // nominal line size (round up)
	  if (i+lsize>lasm->end) 
	      lsize=(lasm->end-i)+1;
	  unsigned csum=lsize+(i>>8)+(i&0xFF);
	  unsigned byt;
	  fprintf(outfile,":");
          fprintf(outfile,"%02x%04x00",lsize,i);
	  for (j=0;j<lsize;j++)
	    {
	      fprintf(outfile,"%02x",lasm->ary[i+j]&mask);
	      csum+=lasm->ary[i+j]&mask;
	      if (siz>8) 
		{
		  fprintf(outfile,"%02x",byt=(lasm->ary[i+j]>>8)&mask);
		  csum+=byt;
		}
	      if (siz>16)
		{
		  fprintf(outfile,"%02x",byt=(lasm->ary[i+j]>>16)&mask);
		  csum+=byt;
		}
	      if (siz>24)
		{
		  fprintf(outfile,"%02x",byt=(lasm->ary[i+j]>>24)&mask);
		  csum+=byt;
		}
	    }
	  fprintf(outfile,"%02x\n",((~csum)+1)&0xFF);
	}
      fprintf(outfile,":00000001FF\n");
      break;
    case 4:   // binary for 32 bit targets only (arch dependent)
      fseek(outfile,lasm->begin,SEEK_SET);
      fwrite(lasm->ary+lasm->begin,1,(lasm->end+1-lasm->begin)*(siz/8),outfile);
      break;
    case 5:
      fseek(outfile,lasm->begin,SEEK_SET);
      for (int i=lasm->begin;i<=lasm->end;i++)
	fputc(lasm->ary[i],outfile);
      break;
      
    default:  // including mode=0;
      if (mode==3) fprintf(outfile,"@%X ",lasm->begin);	    
      for (i=lasm->begin;i<=lasm->end;i+=16)
	{
	  if (mode!=3 && mode!=0)fprintf(outfile,"%0*X: ",siz==8?4:8,i);
	  for (j=0;j<16;j++) 
	    if (i+j<=lasm->end) 
	      {
		if (mode==0) fprintf(outfile,"%0*X: ",siz==8?4:8,i+j);
	      fprintf(outfile,"%0*X ",(siz+3)/4,lasm->ary[i+j]); 
	      if (mode==0) fprintf(outfile,"\n");
	      }
	  if (mode!=0) fprintf(outfile,"\n");
	}
    }
  
  if (outfile!=stdout) fclose(outfile);
  return 0;
}

